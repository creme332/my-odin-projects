const model = (() => {
    /**
     * Stores the different neighbours array generated by knightMoves(). 
     * This data will be used for animation.
     */
    const neighbourStorage = (() => {
      const storage = [];
      function empty() {
        storage.splice(0, storage.length);
      }
      function save(list) {
        storage.push(list);
      }
      function output() {
        console.log(JSON.stringify(storage));
      }
      function get() {
        return storage;
      }
      return { empty, save, output, get };
    })();
  
    function knightMoves(start, end) {
      function getNeighbours(nodeIndex) {
        const dx = [-1, -1, -2, -2, 1, 1, 2, 2]; // change in row
        const dy = [-2, 2, -1, 1, 2, -2, 1, -1]; // change in col
        const x = parseInt(nodeIndex / 8, 10);
        const y = nodeIndex % 8;
        const neighbours = [];
  
        for (let i = 0; i < dx.length; i++) {
          const xx = x + dx[i];
          const yy = y + dy[i];
  
          // skip invalid coordinates
          if (!(xx < 0 || yy < 0 || xx > 7 || yy > 7)) {
            neighbours.push(8 * xx + yy);
          }
        }
  
        return neighbours;
      }
  
      if (start === end) {
        return [start];
      }
  
      const queue = [start]; // stores next node to be visited
      const visited = new Set(queue); // stores indices of nodes that have already been visited.
      const distanceFromStart = new Map([[start, 0]]); // distanceFromStart.get(nodeIndex) : shortest distance from start to node is k units.
      const parent = new Map([[start, -1]]); // parent.get(nodeIndex2) = nodeIndex1 : node1 is the parent of node2 for shortest path from start -> end.
      let done = false;
  
      while (queue.length > 0 && !done) {
        // get first element of queue and pop it.
        const currentPosition = queue.shift();
  
        // get unvisited neighbours of currentPosition
        const unvisitedNeighbours = getNeighbours(currentPosition).filter(
          (el) => !visited.has(el)
        );

        // save these neighbours for animation later
        if(unvisitedNeighbours.length>0){
            neighbourStorage.save(unvisitedNeighbours);
        }

        unvisitedNeighbours.forEach((nextPosition) => {
          visited.add(nextPosition);
          queue.push(nextPosition);
          distanceFromStart.set(
            nextPosition,
            1 + distanceFromStart.get(currentPosition)
          );
          parent.set(nextPosition, currentPosition);
  
          // optional optimisation : end loop as soon as we encounter destination
          if (nextPosition === end) done = true;
        });
      }
  
      // get all nodes from start -> end
      const path = []; // array of coordinates
      let current = end;
      while (current !== -1) {
        path.unshift(current);
        current = parent.get(current);
      }
      return path;
    }
  
    return { knightMoves, neighbourStorage };
  })();

  export default model;